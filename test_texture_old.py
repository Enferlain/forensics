import cv2import numpy as npfrom PIL import Imageimport rembgimport argparseimport matplotlib.pyplot as pltfrom skimage.restoration import denoise_tv_chambolleclass HighSensitivityIntegrityScorer:    def __init__(self, rembg_session=None):        if rembg_session is None:            self.rembg_session = rembg.new_session(providers=['CPUExecutionProvider'])        else:            self.rembg_session = rembg_session    def _get_subject_mask(self, pil_image: Image.Image) -> np.ndarray:        output_image = rembg.remove(pil_image, session=self.rembg_session)        mask = np.array(output_image.convert("RGBA"))[:, :, 3] > 128        return mask    def score(self, image: Image.Image) -> dict:        img_rgb = np.array(image.convert("RGB"))        gray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY).astype(np.float32) / 255.0        mask = self._get_subject_mask(image)                if not np.any(mask):            return {"score": 0.0, "cleanliness": 0.0, "sharpness": 0.0}        # 1. TV Denoising & Residual Variance        denoised = denoise_tv_chambolle(gray, weight=0.1)        residual = np.abs(gray - denoised)        # 2. Extreme Flat-Zone Isolation (Bottom 20% of variance)        local_mean = cv2.blur(gray, (5, 5))        local_sq_mean = cv2.blur(gray**2, (5, 5))        local_var = local_sq_mean - local_mean**2        flat_mask = (local_var < np.percentile(local_var[mask], 20)) & mask                # 3. Calculate Noise Variance (The "Grain" factor)        if np.any(flat_mask):            noise_factor = np.std(residual[flat_mask]) * 100        else:            noise_factor = np.std(residual[mask]) * 100        # 4. Sharpness (Tenengrad with Sigmoid Saturation)        gx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)        gy = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)        mag = np.sqrt(gx**2 + gy**2)        edge_acutance = np.percentile(mag[mask], 98)                # Sharpness Sigmoid        sharp_score = 10.0 / (1.0 + np.exp(-2.5 * (edge_acutance - 1.5)))        # 5. High Sensitivity Normalization        # e^-6.0 creates a steep drop-off after 0.42        clean_score = 10.0 * np.exp(-6.0 * max(0, noise_factor - 0.42))                final = (clean_score * 0.85) + (sharp_score * 0.15)                return {            "score": float(np.clip(final, 0.0, 10.0)),            "cleanliness": float(clean_score),            "sharpness": float(sharp_score),            "noise_factor": float(noise_factor),            "edge_acutance": float(edge_acutance),            "residual": residual,            "flat_mask": flat_mask,            "img_rgb": img_rgb,            "mask": mask        }if __name__ == "__main__":    parser = argparse.ArgumentParser()    parser.add_argument("image_path")    args = parser.parse_args()    pil_img = Image.open(args.image_path).convert("RGB")    scorer = HighSensitivityIntegrityScorer()    res = scorer.score(pil_img)    print(f"\n--- High-Sensitivity Integrity Analysis ---")    print(f"Final Score:      {res['score']:.4f} / 10.0")    print(f"Cleanliness:      {res['cleanliness']:.4f} (Target > 9.0)")    print(f"Sharpness:        {res['sharpness']:.4f} (Sigmoid Saturation)")    print(f"Noise Factor:     {res['noise_factor']:.4f} (Target < 0.45)")    print(f"Edge Acutance:    {res['edge_acutance']:.4f}")    print(f"------------------------------------------\n")    # --- RESTORED VISUALIZATION BLOCK ---    fig, axes = plt.subplots(1, 3, figsize=(18, 6))        # Plot 1: Subject Isolation    sub_img = res['img_rgb'].copy()    sub_img[~res['mask']] = 0    axes[0].imshow(sub_img)    axes[0].set_title("Target Subject")        # Plot 2: Scoring Zones (Where the stipple grain is measured)    axes[1].imshow(res['flat_mask'], cmap='gray')    axes[1].set_title("Flat Zones (Scoring Areas)")        # Plot 3: TV Residual (The noise floor)    # Scaled vmin/vmax to make the grain visible    axes[2].imshow(res['residual'], cmap='hot', vmin=0, vmax=0.03)    axes[2].set_title("TV Residual Map\n(Bright = Stipple Grain)")    for ax in axes:        ax.axis('off')        plt.tight_layout()    plt.show()